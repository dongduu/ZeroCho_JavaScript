<script>
function a( ) { } // 함수선언문(보통 세미콜론을 붙이지 않는다.)
const b = function( ) { }; //함수표현식
const c = ( ) => { }; // 화살표함수
a( ); // 호출

function d() {
    return '반환값'; // 돌려주는 값 지정
}
d();
    > "반환값"

function e() {
    return '반환값'; // 함수의 종료를 의미
    console.log('hello'); // 함수가 위에서 종료되어 실행되지 못함
}
e();
    > "반환값"

function f() {
    return ; // undifined 생략(원래 기복적으로 항상 마지막열에 있음)
}
f();
    > undifined

function g() {
    return [1,5]; // 돌려주는 값 지정
}
g();
    > (2) [1,5]

function h() {
    if (false) {
        return;
    } else {
        console.log("실행됩니다.");
    }
}
a();
    > "실행됩니다."

// parameter(매개변수)과 argument(인수)
function a(parameter) {
    console.log(parameter);
}
a(argument);
    > argument

function a(w, x, y, z) {
    console.log(w, x, y, z); // 매개변수와 인수가 여러개여도 가능
}
a('Hello', 'parameter', 'argument');
    > a('Hello', 'parameter', 'argument', undefined)

function add(x, y) {
    return(x + y);
}
a(3, 5);
    > 8

function a(w, x) {
    console.log(w, x); // 매개변수와 인수가 여러개여도 가능
}
a('Hello', 'parameter', 'argument');
    > a('Hello', 'parameter')

// 객체 리터럴
const dongdu = {
    name: '이동주',
    year: 2000,
    month: 04,
    date: 12,
    gender: 'F',
};
console.log(dongdu.name);
console.log(dongdu['name']);
console.log(dongdu.year);
console.log(dongdu['year']);

dongdu.year = 2001; // 속성 수정
console.log(dongdu.year);

dongdu.age = 22; // 속성 추가
console.log(dongdu.age);

delete dongdu.name; // 속성 제거
console.log(dongdu.name);
    > undefined

// 메서드 이해하기
const debug = {
    log: function(value) { // 객체의 속성값을 함수로 넣었을 때, 그것을 특별히 메서드라고 함
        console.log(value);
    },
};
debug.log('Heelo, Method')

// 객체 간의 비교
{} === {} // 객체(배열, 함수 포함)끼리는 모양이 같아도 항상 false
    > false

// 객체 간의 비교에서 true가 나올 수 있게 하는 방법(메모리형태로 생각)
const a = {name: dongdu};
const array = [1, 2, a];
console.log(a === array[2]);
-----------------------------
const c = {name: 'dd'};
const d = c; 
c.name = 'hero';
console.log(c.name);
</script>